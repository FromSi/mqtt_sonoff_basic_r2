package mqtt_sonoff_basic_r2

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/google/uuid"
	mqtt "github.com/mochi-mqtt/server/v2"
	mqttauth "github.com/mochi-mqtt/server/v2/hooks/auth"
	"github.com/mochi-mqtt/server/v2/listeners"
	"github.com/mochi-mqtt/server/v2/packets"
	"log"
	"math"
	"math/rand"
	"strings"
	"time"
)

type SonoffBasicR2 struct {
	server                          *mqtt.Server
	qos                             byte
	isOwnServer                     bool
	connected                       chan string
	disconnected                    chan string
	ctxCmndResponseTimeoutInSeconds uint
}

func NewSonoffBasicR2(ip string, port uint16, qos byte) (*SonoffBasicR2, error) {
	server := mqtt.New(
		&mqtt.Options{
			InlineClient: true,
		},
	)

	id := uuid.New().String()
	address := fmt.Sprintf("%s:%d", ip, port)

	tcp := listeners.NewTCP(listeners.Config{ID: id, Address: address})
	err := server.AddListener(tcp)

	if err != nil {
		return nil, err
	}

	err = server.AddHook(new(mqttauth.AllowHook), nil)

	if err != nil {
		return nil, err
	}

	return &SonoffBasicR2{
		server:                          server,
		qos:                             qos,
		isOwnServer:                     true,
		connected:                       make(chan string),
		disconnected:                    make(chan string),
		ctxCmndResponseTimeoutInSeconds: 10,
	}, nil
}

func NewSonoffBasicR2WithServer(server *mqtt.Server, qos byte) (*SonoffBasicR2, error) {
	if !server.Options.InlineClient {
		return nil, errors.New("inline_client must be true")
	}

	return &SonoffBasicR2{
		server:                          server,
		qos:                             qos,
		isOwnServer:                     false,
		connected:                       make(chan string),
		disconnected:                    make(chan string),
		ctxCmndResponseTimeoutInSeconds: 10,
	}, nil
}

func (sonoffBasicR2 SonoffBasicR2) GetCtxCmndResponseTimeoutInSeconds() uint {
	return sonoffBasicR2.ctxCmndResponseTimeoutInSeconds
}

func (sonoffBasicR2 *SonoffBasicR2) SetCtxCmndResponseTimeoutInSeconds(value uint) {
	sonoffBasicR2.ctxCmndResponseTimeoutInSeconds = value
}

func (sonoffBasicR2 SonoffBasicR2) TeleConnected() <-chan string {
	return sonoffBasicR2.connected
}

func (sonoffBasicR2 SonoffBasicR2) TeleDisconnected() <-chan string {
	return sonoffBasicR2.disconnected
}

func (sonoffBasicR2 SonoffBasicR2) Serve() error {
	topicTeleConnected := sonoffBasicR2.getFullTeleTopic("+", "LWT")
	subscribeConnected := func(cl *mqtt.Client, sub packets.Subscription, pk packets.Packet) {
		defer func() {
			if r := recover(); r != nil {
				log.Println("warning: channel_connected is closed")
			}
		}()

		if string(pk.Payload) == "Online" {
			sonoffBasicR2.connected <- strings.Split(pk.TopicName, "/")[1]
		}
	}

	err := sonoffBasicR2.server.Subscribe(topicTeleConnected, sonoffBasicR2.generateSubscriptionId(), subscribeConnected)

	if err != nil {
		return err
	}

	topicTeleDisconnected := sonoffBasicR2.getFullTeleTopic("+", "LWT")
	subscribeDisconnected := func(cl *mqtt.Client, sub packets.Subscription, pk packets.Packet) {
		defer func() {
			if r := recover(); r != nil {
				log.Println("warning: channel_disconnected is closed")
			}
		}()

		if string(pk.Payload) == "Offline" {
			sonoffBasicR2.disconnected <- strings.Split(pk.TopicName, "/")[1]
		}
	}

	err = sonoffBasicR2.server.Subscribe(topicTeleDisconnected, sonoffBasicR2.generateSubscriptionId(), subscribeDisconnected)

	if err != nil {
		return err
	}

	if sonoffBasicR2.isOwnServer {
		return sonoffBasicR2.server.Serve()
	}

	return nil
}

func (sonoffBasicR2 SonoffBasicR2) Close() error {
	close(sonoffBasicR2.connected)
	close(sonoffBasicR2.disconnected)

	if sonoffBasicR2.isOwnServer {
		return sonoffBasicR2.server.Close()
	}

	return nil
}

func (sonoffBasicR2 SonoffBasicR2) StatusZero(id string) (*AutoGenerated, error) {
	response, err := sonoffBasicR2.getCmndResponse(id, "STATUS0", "STATUS0", "")

	if err != nil {
		return nil, err
	}

	return UnmarshalAutoGenerated([]byte(response))
}

func (sonoffBasicR2 SonoffBasicR2) StatusOne(id string) (*StatusOne, error) {
	response, err := sonoffBasicR2.getCmndResponse(id, "STATUS", "STATUS1", "1")

	if err != nil {
		return nil, err
	}

	return UnmarshalStatusOne([]byte(response))
}

func (sonoffBasicR2 SonoffBasicR2) StatusTwo(id string) (*StatusTwo, error) {
	response, err := sonoffBasicR2.getCmndResponse(id, "STATUS", "STATUS2", "2")

	if err != nil {
		return nil, err
	}

	return UnmarshalStatusTwo([]byte(response))
}

func (sonoffBasicR2 SonoffBasicR2) StatusThree(id string) (*StatusThree, error) {
	response, err := sonoffBasicR2.getCmndResponse(id, "STATUS", "STATUS3", "3")

	if err != nil {
		return nil, err
	}

	return UnmarshalStatusThree([]byte(response))
}

func (sonoffBasicR2 SonoffBasicR2) StatusFour(id string) (*StatusFour, error) {
	response, err := sonoffBasicR2.getCmndResponse(id, "STATUS", "STATUS4", "4")

	if err != nil {
		return nil, err
	}

	return UnmarshalStatusFour([]byte(response))
}

func (sonoffBasicR2 SonoffBasicR2) StatusFive(id string) (*StatusFive, error) {
	response, err := sonoffBasicR2.getCmndResponse(id, "STATUS", "STATUS5", "5")

	if err != nil {
		return nil, err
	}

	return UnmarshalStatusFive([]byte(response))
}

func (sonoffBasicR2 SonoffBasicR2) StatusSix(id string) (*StatusSix, error) {
	response, err := sonoffBasicR2.getCmndResponse(id, "STATUS", "STATUS6", "6")

	if err != nil {
		return nil, err
	}

	return UnmarshalStatusSix([]byte(response))
}

func (sonoffBasicR2 SonoffBasicR2) StatusSeven(id string) (*StatusSeven, error) {
	response, err := sonoffBasicR2.getCmndResponse(id, "STATUS", "STATUS7", "7")

	if err != nil {
		return nil, err
	}

	return UnmarshalStatusSeven([]byte(response))
}

func (sonoffBasicR2 SonoffBasicR2) StatusEight(id string) (*StatusEight, error) {
	response, err := sonoffBasicR2.getCmndResponse(id, "STATUS", "STATUS8", "8")

	if err != nil {
		return nil, err
	}

	return UnmarshalStatusEight([]byte(response))
}

func (sonoffBasicR2 SonoffBasicR2) StatusEleven(id string) (*StatusEleven, error) {
	response, err := sonoffBasicR2.getCmndResponse(id, "STATUS", "STATUS11", "11")

	if err != nil {
		return nil, err
	}

	return UnmarshalStatusEleven([]byte(response))
}

func (sonoffBasicR2 SonoffBasicR2) StatusPhysicalButton(id string) (bool, error) {
	response, err := sonoffBasicR2.getCmndResponse(id, "SETOPTION73", "RESULT", "")

	if err != nil {
		return false, err
	}

	var data map[string]string

	if err := json.Unmarshal([]byte(response), &data); err != nil {
		return false, err
	}

	result, ok := data["SetOption73"]

	if !ok {
		return false, errors.New("SetOption73 not found")
	}

	return result == "OFF", nil
}

func (sonoffBasicR2 SonoffBasicR2) PowerOn(id string) {
	topicCmnd := sonoffBasicR2.getFullCmndTopic(id, "POWER")
	_ = sonoffBasicR2.server.Publish(topicCmnd, []byte("ON"), false, sonoffBasicR2.qos)
}

func (sonoffBasicR2 SonoffBasicR2) PowerOff(id string) {
	topicCmnd := sonoffBasicR2.getFullCmndTopic(id, "POWER")
	_ = sonoffBasicR2.server.Publish(topicCmnd, []byte("OFF"), false, sonoffBasicR2.qos)
}

func (sonoffBasicR2 SonoffBasicR2) PowerToggle(id string) {
	topicCmnd := sonoffBasicR2.getFullCmndTopic(id, "POWER")
	_ = sonoffBasicR2.server.Publish(topicCmnd, []byte("TOGGLE"), false, sonoffBasicR2.qos)
}

func (sonoffBasicR2 SonoffBasicR2) PhysicalButtonOn(id string) {
	topicCmnd := sonoffBasicR2.getFullCmndTopic(id, "SETOPTION73")
	_ = sonoffBasicR2.server.Publish(topicCmnd, []byte("0"), false, sonoffBasicR2.qos)
}

func (sonoffBasicR2 SonoffBasicR2) PhysicalButtonOff(id string) {
	topicCmnd := sonoffBasicR2.getFullCmndTopic(id, "SETOPTION73")
	_ = sonoffBasicR2.server.Publish(topicCmnd, []byte("1"), false, sonoffBasicR2.qos)
}

func (sonoffBasicR2 SonoffBasicR2) generateSubscriptionId() int {
	return rand.New(rand.NewSource(time.Now().UnixNano())).Intn(math.MaxInt32)
}

func (sonoffBasicR2 SonoffBasicR2) getFullTopic(prefix string, id string, topic string) string {
	return fmt.Sprintf("%s/%s/%s", prefix, id, topic)
}

func (sonoffBasicR2 SonoffBasicR2) getFullStatTopic(id string, topic string) string {
	return sonoffBasicR2.getFullTopic("stat", id, topic)
}

func (sonoffBasicR2 SonoffBasicR2) getFullCmndTopic(id string, topic string) string {
	return sonoffBasicR2.getFullTopic("cmnd", id, topic)
}

func (sonoffBasicR2 SonoffBasicR2) getFullTeleTopic(id string, topic string) string {
	return sonoffBasicR2.getFullTopic("tele", id, topic)
}

func (sonoffBasicR2 SonoffBasicR2) getCmndResponse(id string, topicCmnd string, topicStat string, value string) (string, error) {
	fullTopicStat := sonoffBasicR2.getFullStatTopic(id, topicStat)
	fullTopicCmnd := sonoffBasicR2.getFullCmndTopic(id, topicCmnd)

	ctx, cancel := context.WithTimeout(
		context.Background(),
		time.Duration(sonoffBasicR2.ctxCmndResponseTimeoutInSeconds)*time.Second,
	)

	defer cancel()

	result := make(chan string, 1)

	defer close(result)

	subscriptionId := sonoffBasicR2.generateSubscriptionId()
	subscribeResponse := func(cl *mqtt.Client, sub packets.Subscription, pk packets.Packet) {
		result <- string(pk.Payload)
	}

	err := sonoffBasicR2.server.Subscribe(fullTopicStat, subscriptionId, subscribeResponse)

	defer func(server *mqtt.Server, filter string, subscriptionId int) {
		_ = server.Unsubscribe(filter, subscriptionId)
	}(sonoffBasicR2.server, fullTopicStat, subscriptionId)

	if err != nil {
		return "", err
	}

	_ = sonoffBasicR2.server.Publish(fullTopicCmnd, []byte(value), false, sonoffBasicR2.qos)

	select {
	case <-ctx.Done():
		return "", fmt.Errorf(
			"operation not completed in %d seconds",
			sonoffBasicR2.ctxCmndResponseTimeoutInSeconds,
		)
	case data := <-result:
		return data, nil
	}
}
